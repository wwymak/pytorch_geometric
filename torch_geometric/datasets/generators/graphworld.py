import os.path as osp
from typing import Callable, List, Optional, Union

import torch
import enum

from torch_geometric.data import Data, InMemoryDataset
from torch_geometric.datasets import StochasticBlockModelDataset
from torch_geometric.io import read_npz
from torch_geometric.utils import stochastic_blockmodel_graph

from .graph_generator import GraphGenerator
from sklearn.preprocessing import normalize
import numpy as np

class MatchType(enum.Enum):
    """Indicates type of feature/graph membership matching to do.
    RANDOM: feature memberships are generated randomly.
    NESTED: for # feature groups >= # graph groups. Each feature cluster is a
      sub-cluster of a graph cluster. Multiplicity of sub-clusters per
      graph cluster is kept as uniform as possible.
    GROUPED: for # feature groups <= # graph groups. Each graph cluster is a
      sub-cluster of a feature cluster. Multiplicity of sub-clusters per
      feature cluster is kept as uniform as possible.
    """
    RANDOM = 1
    NESTED = 2
    GROUPED = 3


class StochasticBlockModelGraph(GraphGenerator):
    def __init__(
        self,
            motif: Callable,
            block_sizes: Union[List[int], torch.Tensor],
            edge_probs: Union[List[List[float]], torch.Tensor],
            directed: bool = False,
            out_degs=None,
            feature_center_distance=0.0,
            feature_dim=0,
            num_feature_groups=1,
            # feature_group_match_type=MatchType.RANDOM,
            feature_cluster_variance=1.0,
            edge_feature_dim=0,
            edge_center_distance=0.0,
            edge_cluster_variance=1.0,
            normalize_features=True,
            num_nodes: int = 300,
            seed:int = None,
    ):
        self.edge_probs = edge_probs
        self.block_sizes = block_sizes
        self.out_degs = out_degs
        self.directed = directed
        self.x = None
        super().__init__(num_nodes, motif, seed)

    def generate_node_features(
            self,
            center_var,
            feature_dim: int,
            num_groups,
            match_type=MatchType.RANDOM,
            cluster_var=1.0,
            normalize_features=True) -> torch.Tensor:
        r"""

        Args:
            center_var: (float) variance of feature cluster centers. When this is 0.0,
                the signal-to-noise ratio is 0.0. When equal to cluster_var, SNR is 1.0.
            feature_dim: (int) dimension of the multivariate normal.
            num_groups: (int) number of centers. Generated by a multivariate normal with
                mean zero and covariance matrix cluster_var * I_{feature_dim}.
            match_type: (MatchType) see sbm_simulator.MatchType for details.
            cluster_var: (float) variance of feature clusters around their centers.

        Returns:

        """
        feature_memberships = _GenerateFeatureMemberships(
            graph_memberships=sbm_data.graph_memberships,
            num_groups=num_groups,
            match_type=match_type)

        # Get centers
        centers = []
        center_cov = np.identity(feature_dim) * center_var
        cluster_cov = np.identity(feature_dim) * cluster_var
        for _ in range(num_groups):
            center = np.random.multivariate_normal(
                np.zeros(feature_dim), center_cov, 1)[0]
            centers.append(center)
        features = []
        for cluster_index in feature_memberships:
            feature = np.random.multivariate_normal(centers[cluster_index], cluster_cov,
                                                    1)[0]
            features.append(feature)
        features = np.array(features)
        if normalize_features:
            features = normalize(features)
        return torch.tensor(features)

    def generate_edge_features(
            self,
            feature_dim: int,
            center_distance: float =0.0,
            cluster_variance: float =1.0
    ) -> torch.Tensor:
        r"""
            Generates edge feature distribution via inter-class vs intra-class.
            Edge features have two centers: one at (0, 0, ....) and one at
            (center_distance, center_distance, ....) for inter-class and intra-class
            edges (respectively). They are generated from a multivariate normal with
            covariance matrix = cluster_variance * I_d.

            Args:
            feature_dim: (int) dimension of the multivariate normal.
            center_distance: (float) per-dimension distance between the intra-class and
              inter-class means. Increasing this makes the edge feature signal stronger.
            cluster_variance: (float) variance of clusters around their centers.
  """
        center0 = np.zeros(shape=(feature_dim,))
        center1 = np.ones(shape=(feature_dim,)) * center_distance
        covariance = np.identity(feature_dim) * cluster_variance
        edge_features = {}
        for edge in sbm_data.graph.edges():
            vertex1 = int(edge.source())
            vertex2 = int(edge.target())
            edge_tuple = tuple(sorted((vertex1, vertex2)))
            if (sbm_data.graph_memberships[vertex1] ==
                    sbm_data.graph_memberships[vertex2]):
                center = center1
            else:
                center = center0
            edge_features[edge_tuple] = np.random.multivariate_normal(
                center, covariance, 1)[0]
        return edge_features

    def generate_base_graph(self) -> Data:
        self.edge_index = stochastic_blockmodel_graph(
            self.block_sizes, self.edge_probs, directed=not self.directed)
        if self.motif:
            self.attach_motif()
        x = self.generate_node_features()
        edge_attr = self.generate_edge_features()

        data = Data(x=x, edge_index=self.edge_index, y=self.node_label,
                    edge_attr=edge_attr)

        return data




class GraphWorld(GraphGenerator):
    def __init__(
            self,
            motif: Callable,
            block_sizes: Union[List[int], torch.Tensor],
            edge_probs: Union[List[List[float]], torch.Tensor],
            directed: bool = False,
            out_degs=None,
            feature_center_distance=0.0,
            feature_dim=0,
            num_feature_groups=1,
            # feature_group_match_type=MatchType.RANDOM,
            feature_cluster_variance=1.0,
            edge_feature_dim=0,
            edge_center_distance=0.0,
            edge_cluster_variance=1.0,
            normalize_features=True,
            num_nodes: int = 300,
            p_to_q_min=1,
            p_to_q_max=64,
            seed=None,
    ):
        # self.num_edges = num_edges
        # self.num_motifs = num_motifs
        self.block_sizes = block_sizes
        self.edge_probs = edge_probs
        self.directed = directed
        super().__init__(num_nodes=num_nodes, motif=motif, seed=seed)

    def generate_feature(self, num_features: int = 10):
        self.x = torch.ones((self.num_nodes, num_features), dtype=torch.float)

    def generate_base_graph(self):
        self.edge_index = stochastic_blockmodel_graph(self.block_sizes,
                                                      self.edge_probs,
                                                      self.directed)
        self.attach_motif()
        self.generate_feature()

        data = Data(x=self.x, edge_index=self.edge_index, y=self.node_label,
                    expl_mask=self.expl_mask, edge_label=self.edge_label)

        return data

    def generate_graphs(self):
        pass
    # generate muliple graphs as per paper using p_q ration
